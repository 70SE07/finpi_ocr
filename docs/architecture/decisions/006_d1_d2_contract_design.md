# ADR-006: Дизайн контракта D1 → D2

**Статус:** Принято  
**Вопрос плана:** Новый (обсуждение D1→D2)

---

## Контекст

D1 (Extraction) передает данные в D2 (Parsing). Это наша зона свободы - мы авторы и создаем правила.

Вопрос: какую структуру данных передавать чтобы D2 мог достичь **100% качества** парсинга?

> **Почему 100%?** Одна ошибка OCR (БЕКОН → БЕТОН) = неверная категория = бесполезный результат. См. PROJECT_VISION.md

---

## Варианты

### Вариант A: Только полный текст

```python
class RawOCRResult:
    full_text: str  # "REWE\nSchweinenackenbraten 10,85 A\n..."
```

**Плюсы:**
- Простота
- Regex работает
- Контекст рядом
- Быстрый старт

**Минусы:**
- Потеря структуры layout
- Нет координат
- Сложные 2-3 колоночные чеки сливаются в кашу
- Нет confidence - не знаем где OCR ошибся

### Вариант B: Только слова с координатами

```python
class RawOCRResult:
    words: List[Word]  # [{"text": "REWE", "x": 100, "y": 50}, ...]
```

**Плюсы:**
- Layout понятен
- Колонки разделяемы
- Confidence доступен
- Точная привязка цены к товару

**Минусы:**
- Сложнее обработка
- Нужен алгоритм сборки слов в строки
- Больше данных

### Вариант C: ОБА (принят)

```python
class RawOCRResult:
    full_text: str
    words: List[Word]
```

---

## Решение

**Передавать и `full_text`, и `words[]` с координатами.**

Это даст D2 максимум информации для достижения **100% качества**.

### Структура контракта D1 → D2

```python
@dataclass
class BoundingBox:
    x: int          # Левый верхний угол X
    y: int          # Левый верхний угол Y
    width: int      # Ширина
    height: int     # Высота

@dataclass
class Word:
    text: str                    # Текст слова
    bounding_box: BoundingBox    # Координаты
    confidence: float            # Уверенность OCR (0.0 - 1.0)

@dataclass
class OCRMetadata:
    source_file: str             # Имя исходного файла
    image_width: int             # Ширина изображения
    image_height: int            # Высота изображения
    processed_at: str            # Timestamp обработки
    preprocessing_applied: List[str]  # Что было применено (grayscale, deskew, etc.)

@dataclass
class RawOCRResult:
    full_text: str               # Полный текст одной строкой (для regex, паттернов)
    words: List[Word]            # Слова с координатами (для layout, структуры)
    metadata: OCRMetadata        # Метаданные обработки
```

---

## Почему такое решение

### full_text нужен для:
- Быстрый поиск паттернов (`"zu zahlen"`, `"SUMME"`)
- Определение локали по ключевым словам
- Regex для извлечения дат, сумм
- Простые операции без работы с координатами

### words[] нужен для:
- Понимание layout (где левая колонка, где правая)
- Разделение названия товара от цены по X-координате
- Обработка 2-3 колоночных чеков
- Группировка слов в строки по Y-координате
- Понимание где OCR мог ошибиться (низкий confidence)

### Реальный пример

```
Строка в full_text:
"Schweinenackenbraten 10,85 A 1,207 kg x 8,99 EUR/kg"

Вопрос: Это один товар или два?

БЕЗ координат: НЕПОНЯТНО

С координатами:
- "Schweinenackenbraten" x=50, y=200
- "10,85" x=400, y=200
- "A" x=450, y=200
- "1,207" x=50, y=220
- ...

ПОНЯТНО: 10,85 справа (x=400) = это цена. 
Следующая строка (y=220) = детализация веса.
```

---

## Последствия

1. **Файл контракта:** `contracts/d1_extraction_dto.py` обновлен
2. **D1 должен выдавать:** и текст, и слова с координатами
3. **D2 может использовать:** что удобнее для конкретной задачи
4. **Гибкость:** D2 сам решает когда использовать full_text, а когда words[]

---

## Использование в D2

```python
# Быстрый поиск локали
if "zu zahlen" in raw_ocr.full_text.lower():
    locale = "de_DE"

# Точное извлечение товаров
for word in raw_ocr.words:
    if word.bounding_box.x > image_width * 0.7:
        # Это правая колонка - скорее всего цена
        prices.append(word.text)
```

---

## Известные ограничения

### Потеря семантики блоков

Google Vision возвращает структуру `pages → blocks → paragraphs → words`, где `block` имеет тип (TEXT, TABLE, BARCODE и т.д.).

**Текущее решение:** Мы извлекаем только `words[]`, теряя информацию о типе блока.

**Почему это приемлемо сейчас:**
- Чеки — это линейные документы (текст сверху вниз)
- Табличная структура восстанавливается по X/Y координатам
- Для 100+ локалей паттерн одинаков

**План на будущее:** Если понадобится семантика блоков (например, для чеков с QR-кодами или штрих-кодами), добавить поле:

```python
class Word(BaseModel):
    text: str
    bounding_box: BoundingBox
    confidence: float
    block_type: Optional[str] = None  # TEXT, TABLE, BARCODE
```

**Ссылка:** Замечание от внешнего аудита (31.12.2024)
