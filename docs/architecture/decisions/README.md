# Architecture Decision Records (ADR)

Реестр архитектурных решений проекта Finpi OCR.

## Зачем нужен ADR

Фиксация фундаментальных решений, чтобы:
- Не объяснять заново при смене контекста/AI
- Иметь единый источник правды
- Понимать почему было принято то или иное решение

---

## Индекс решений

| ID | Название | Статус | Вопрос плана |
|----|----------|--------|--------------|
| [001](001_domain_separation.md) | Разделение на домены | Принято | Q1.2 |
| [002](002_domain_responsibilities.md) | ЦКП доменов | Принято | Q1.1 |
| [003](003_raw_ocr_contract_stability.md) | Стабильность RawOCRResult | Принято | Q1.3 |
| [004](004_dto_contracts.md) | Контракты DTO между доменами | Принято | Q2.0 |
| [005](005_contract_boundaries.md) | Границы контрактов (жесткие/гибкие) | Принято | Q2.0 (финал) |
| [006](006_d1_d2_contract_design.md) | Дизайн контракта D1→D2 | Принято | Новый |
| [007](007_d3_categorization_overview.md) | Понимание D3 (внешний домен) | Информационный | - |
| [008](008_d2_name_cleaning_rules.md) | Правила очистки name в D2 | Утверждено | Q2.2, Q2.2.1 |
| [009](009_d2_quality_guarantees.md) | Гарантии качества D2 (100% success) | Утверждено | Q2.3, Q2.4 |
| [010](010_locale_store_hierarchy.md) | Иерархия Locale/Store | Утверждено | Q3.1, Q3.2, Q3.3, Q3.4 |
| [011](011_validation_strategy.md) | Стратегия валидации (Checksum) | Утверждено | Q4.1, Q4.2 |
| [012](012_ground_truth_system.md) | Система Ground Truth | Утверждено | Q5.1, Q5.2 |
| [013](013_clean_code_srp.md) | Clean Code и SRP | Утверждено | Фундаментальный |

---

## Ключевое понимание архитектуры

| Домен | Задача | Технология | Зона |
|-------|--------|------------|------|
| **D1** | Extraction (RAW OCR) | Google Vision OCR | Наша |
| **D2** | Parsing | **КОД** (Python, regex, алгоритмы) | Наша |
| **D3** | Categorization | LLM | **НЕ наша** |

---

## Ключевое понимание D3

> **Задача D2 для D3: Передать `name` товара ТОЧНО как на чеке, без потерь и искажений.**

D3 (Categorization) - внешний домен, не наша зона ответственности. Но мы понимаем:
- D3 сам понимает языки через LLM (Large Language Model)
- D3 работает с сокращениями (расшифровывает их через LLM)
- D3 категоризирует через Constitution + Directories + LLM
- Контракт D2 к D3 = `RawReceiptDTO` (1 в 1 с finpi_parser_photo)

**D2 НЕ должен:**
- Переводить `name` (с одного языка на другой) - УТВЕРЖДЕНО

**D2 ДОЛЖЕН убирать из `name`:** (УТВЕРЖДЕНО)
- SKU / Коды товаров (`826945`, `(399)`)
- Налоговые классы (`A`, `B`, `+A`, `A_`, `C_`)

**D2 НЕ ДОЛЖЕН убирать из `name`:** (УТВЕРЖДЕНО)
- Сокращения магазина / Private Label (`MC`, `JZN`, `F&G`, `CONSU`) - LLM справится
- Вес/размер в названии (`500g`, `3.5%`, `6x1.5L`) - важно для категоризации

**D2 НЕ ПЕРЕДАЕТ в D3:** (УТВЕРЖДЕНО)
- Категории магазина (HIT: `OBST & GEMÜSE`, `LEBENSMITTEL`) - D3 сам категоризирует

Подробнее: [ADR-008](008_d2_name_cleaning_rules.md)

Подробнее: [ADR-007](007_d3_categorization_overview.md)

---

## Контракты системы

**Дата верификации:** 2025-12-29

| Контракт | Источник истины | Наш файл | Статус |
|----------|-----------------|----------|--------|
| D1 → D2 | **Наш дизайн (ADR-006)** | `contracts/d1_extraction_dto.py` | **Принято** |
| D2 → D3 | `finpi_parser_photo/domain/dto/raw_receipt_dto.py` | `contracts/d2_parsing_dto.py` | **1 в 1** |
| D3 → Orchestrator | `finpi_parser_photo/domain/dto/parse_receipt_dto.py` | `contracts/d3_categorization_dto.py` | **1 в 1** |

### D1 → D2: Ключевое решение (ADR-006)

**Передавать и `full_text`, и `words[]` с координатами.**

```python
@dataclass
class RawOCRResult:
    full_text: str           # Для regex, паттернов, локали
    words: List[Word]        # Для layout, структуры, точности
    metadata: OCRMetadata    # Метаданные обработки
```

Это дает D2 максимум информации для достижения **100% качества**.

---

## Статус вопросов (из плана)

| ID | Вопрос | Статус |
|----|--------|--------|
| Q1.1 | ЦКП Домена 1 - правильно понят? | Отвечено (ADR-002) |
| Q1.2 | Причины разделения доменов | Отвечено (ADR-001) |
| Q1.3 | RawOCRResult стабилен? | Отвечено (ADR-003) |
| Q1.4 | Дизайн контракта D1→D2 | Отвечено (ADR-006) |
| Q2.0 | Контракты DTO между доменами | Отвечено (ADR-004, ADR-005, ADR-006) |
| Q2.1 | Структура RawReceiptItem (D2→D3) | Отвечено (ADR-005) |
| Q2.2 | name - переводить? | Отвечено (ADR-008) |
| Q2.2.1 | name - очищать? | Отвечено (ADR-008) |
| Q2.3 | Сигналы качества на уровне чека? | Отвечено (ADR-009) |
| Q2.4 | Вариант A (100%) или B (сигналы)? | Отвечено (ADR-009) |
| Q3.1 | Иерархия конфигов (A/B/C)? | Отвечено (ADR-010) |
| Q3.2 | Store detection обязателен? | Отвечено (ADR-010) |
| Q3.3 | Инвестировать в store configs? | Отвечено (ADR-010) |
| Q3.4 | Структура locale config? | Отвечено (ADR-010) |
| Q4.1 | Что делать при checksum mismatch? | Отвечено (ADR-011) |
| Q4.2 | Порог расхождения? | Отвечено (ADR-011) |
| Q5.1 | Структура observations? | Отвечено (ADR-012) |
| Q5.2 | Как устроены эталонные данные? | Отвечено (ADR-012) |

---

## Формат ADR

Каждый ADR содержит:
1. **Контекст** - почему возник вопрос
2. **Вопрос** - что нужно решить
3. **Решение** - что решили
4. **Последствия** - как это влияет на архитектуру
